#!python
#Fusion Table Insert/Update Utility

#from FTSync.MysqlFTSync import MysqlFTSync
from FTSync.PostgresFTSync import PostgresFTSync
from FTClient import FTClient
from FTClient.authorization.clientlogin import ClientLogin
import psycopg2
import logging
from optparse import OptionParser
import contextlib
import sys
import os.path

import settings

if __name__ == "__main__":
    desc = ("Syncs a Postgres table with a Fusion Table, using a sequential "
            "ID field as the key.  The tables must have the same schema, "
            "and must contain a single field that uniquely identifies each "
            "record and is also updated sequentially so every new record "
            "gets a larger value that all previous records")

    usage = """%prog [options] COMMAND FT_ID DB_TABLE

  COMMAND
    DB2FT    Sync records from the Postgres Table into the Fusion Table
    FT2DB    Sync records from the Fusion Table into the Postgres table

  FT_ID
    ID of the fusion table - to find the id, open the table and
    select File/About
  DB_TABLE
    Postgres Table.  Column names must
    match columns in the fusion table
"""
    parser = OptionParser(description=desc, usage=usage)

    parser.set_defaults(loglevel=logging.INFO)
    parser.add_option("-q", "--quiet",
            action="store_const", dest="loglevel", const=logging.ERROR,
            help="Only output error messages")
    parser.add_option("-v", "--verbose",
            action="store_const", dest="loglevel", const=logging.DEBUG,
            help="Output debugging information")
    parser.add_option("--ft_id_field",
            action="store",  default='ft_id', type='string', dest='ft_id_field',
            help="Name of the column in the Postgres table that stores the "
                  "Fusion Table ROWID",
            metavar="FT_ID_FIELD")
    parser.add_option("--seq_field",
            action="store",  default='seqid', type='string', dest='seq_field',
            help="Name of the column in the Postgres table that stores the "
                 "unique key - always called 'seqid' in the Fusion Table",
            metavar="SEQ_FIELD")
    parser.add_option("--max_recs",
            action="store",  default=1000, type='int', dest='max_recs',
            help="Maximum number of records to transfer",
            metavar="MAX_RECS")
#    parser.add_option("--db_name",
#            action="store",  default='Test', type='string', dest='db_name',
#            help="Name of Postgres database to connect to",
#            metavar="DB_NAME")
#    parser.add_option("--settings",
#            action="store", type='string', dest='settings',
#            help="Name of settings file",
#            metavar="SETTINGS")

    (options, args) = parser.parse_args()

    if len(args) < 3:
        parser.error("Not enough arguments.")
    elif len(args) > 3:
        parser.error("Too many arguments.")


#    if 'settings' in options:
#        settingsfile = options['settings']
#    else:
#        settingsfile = os.path.join(os.environ['HOME'], '.ft-sync')
#        if not os.path.exists(settingsfile):
#            settingsfile = '/etc/ft-sync'
#
#    settings = {}
#    with contextlib.closing(open(settingsfile)) as f:
#        exec f in settings

#    try:
#        ft_table_id = int(args[1])
#    except ValueError:
#        parser.error("FT_TABLE_ID must be an integer")

    ft_table_id = args[1]
    db_table = args[2]

    logging.basicConfig(format='%(levelname)s: %(message)s',
                        level=options.loglevel)

    ft_username = settings.FT_USERNAME
    ft_password = settings.FT_PASSWORD
#    ft_tableid = 1358365

    db_host = settings.DB_HOST
    db_user = settings.DB_USER
    db_passwd = settings.DB_PASSWORD
    db_name = settings.DB_NAME

    logging.info ("Connecting to Fusion Tables with user %s", ft_username)

    ft_client = FTClient.ClientLoginFTClient(
            ClientLogin().authorize(ft_username, ft_password))

    logging.info ("Connecting to Postgres with host: %s  user: %s  db: %s "
                  %(db_host, db_user, db_name) )

    postgres_db = psycopg2.connect (
        host = db_host,
        user = db_user,
        password = db_passwd,
        database = db_name)
        #charset = 'utf8')
    postgres_db.autocommit = True

    db_ft_sync = PostgresFTSync (ft_client,
                                 postgres_db,
                                 ft_id_field = options.ft_id_field,
                                 seq_field=options.seq_field)

    command = args[0]
    records_affected = 0
    success = False
    max_records = options.max_recs
    if command == 'DB2FT':
        logging.debug ("Syncing %s to %s for max %s records"
                       % (db_table, ft_table_id, max_records))
        try:
            while records_affected < max_records:
                new_records_affected = db_ft_sync.sync_postgres_to_ft (
                        db_table, ft_table_id)
                if not new_records_affected:
                    break
                records_affected += new_records_affected

            success=True
        except FTClient.FTClientError as e:
            logging.error (e.message)

        except psycopg2.Error as e:
            logging.error (e)
    elif command == 'FT2DB':
        logging.debug ("Syncing %s to %s for max %s records"
                       % (ft_table_id, db_table, max_records))
        try:
            while records_affected < max_records:
                new_records_affected = db_ft_sync.sync_ft_to_postgres (
                        db_table, ft_table_id)
                if not new_records_affected:
                    break
                records_affected += new_records_affected

            success=True
        except FTClient.FTClientError as e:
            logging.error (e.message)

        except psycopg2.Error as e:
            logging.error (e)

    else:
        parser.error("unknown command: %s" % command)


    logging.info ("%s records affected" % records_affected)
    if success:
        logging.info ("Done." )
    else:
        logging.info ("Failed." )
